# This script combines output from the mightyOhm Geiger Counter serial port and USB GPS dongle into a plain text  file

# 1 JUL 2022: changed the default duration to 30 minutes (1800 seconds) and buffer to 1 minute (60 seconds) and interval to 1

# Libraries
#
import serial
import time
from time import sleep
import re
import csv
from datetime import datetime
import matplotlib.pyplot as plt
import statistics
from matplotlib.animation import FuncAnimation
import tweepy
import math

# Authentication Personal Details
#
ACCESS_KEY = 'insert access key here'
ACCESS_SECRET = 'insert access secret here'
BEARER_TOKEN = 'insert bearer token here'
CONSUMER_KEY = 'insert consumer key here'
CONSUMER_SECRET = 'insert consumer secret here'

# Authenticate to Twitter
#
auth = tweepy.OAuthHandler(CONSUMER_KEY, CONSUMER_SECRET)
auth.set_access_token(ACCESS_KEY, ACCESS_SECRET)

# auth = tweepy.Client(BEARER_TOKEN)
#
API = tweepy.API(auth, wait_on_rate_limit=True)

client = tweepy.Client(BEARER_TOKEN, CONSUMER_KEY, CONSUMER_SECRET, ACCESS_KEY, ACCESS_SECRET)

# ~~~~~ Global Variables ~~~~~

# duration: how long the surveyor program should run in seconds. Default value is 3600 seconds or 1 hour.
duration = 1800

# buffer:
buffer = 60 #1800

# interval: Label every Nth tick park on the x axis of the plot generated by plotDataFromFile()
interval = 1 #math.floor(duration/6)

# directory: default location for output data
directory = "/home/pi/radbot/output"

# Set the live plot graph style
plt.style.use('seaborn')

# iniialize arrays for x and y values (for live plotting)
x_values = []
y_values = []

# record the start time for elapsed time calculation
startTime = time.time()
startDateTime = datetime.now()


# ~~~~~ Functions ~~~~~

# generateFileName : return current date/time string to use in the output file name
#
def generateFileName():

    now = datetime.now()
    dateTimeFileName = now.strftime("%Y%m%d_%H%M%S")
    dateTimeFileName = "mightyOhmRadData_" + dateTimeFileName

    return dateTimeFileName + ".csv"

# generatePath : return string combining default file path (directory) with newly generated filename (fname)
#
def generatePath(fname):

    return directory + "/" + fname

# getMeasurement : returns float uSv/hr measurement from serial data using regex, -0.01 if attribute error
#
def getMicrosievertsPerHour(inputString):

    try:
        result = re.search('uSv/hr, (.*), SLOW', inputString).group(1)
        return float(result)

    except AttributeError:
        return -0.01

# getCountsPerSecond : returns integer CPS value from serial string based on regex, -1 if attribute error
#
def getCountsPerSecond(inputString):

    try:
        result = re.search('CPS, (.*), CPM', inputString).group(1)
        return int(result)

    except AttributeError:
        return -1

# getCountsPerMinute : returns integer CPM value from serial string based on regex, -1 if attribute error
#
def getCountsPerMinute(inputString):

    try:
        result = re.search('CPM, (.*), uSv/hr', inputString).group(1)
        return int(result)

    except AttributeError:
        return -1

# writeSerialDataToFile() : generates a filename based on current date/time and creates a new textfile in the
# "directory" path, then logs the start time, connects to serial port, and reads lines from serial port until
# duration is reached
#
def writeSerialDataToFile():

    datafile = generateFileName()
    datapath = generatePath(datafile)

    raddata = open(datapath, 'w')
    now = datetime.now()
    start = now.strftime("%m/%d/%Y %H:%M:%S")
    raddata.write("Sample Start: " + start + "\nDuration: " + str(duration/60) + " minutes" + "\nTime (hh:mm:ss), µSv/hr\n")

    startTime = time.time()

    with serial.Serial(port='/dev/ttyUSB0',
                       baudrate=9600,
                       timeout=1,
                       xonxoff=False,
                       rtscts=False,
                       dsrdtr=True) as s:

        try:
            for line in s:

                elapsed = int(time.time() - startTime)

                if elapsed > 0:

                    dataCap = line.decode('utf-8')
                    now = datetime.now()
                    sampleTime = now.strftime("%H:%M:%S")
                    usv = getMicrosievertsPerHour(dataCap)
                    raddata.write(sampleTime + ", " + str(usv) + "\n")

                if time.time() - startTime >= duration:
                    break

        finally:
            s.close()

    raddata.close()
    return datapath


#
def plotDataFromFile(filename):
    # Empty lists where we'll put x values (aka timestamps) from the data file, labels for the x axis,
    # intervals for the x axism and Y values.
    X = []
    xlabels = []
    xintervals = []
    USV = []
    b = 0
    bufferSum = 0
    buffCount = 0

    # Current time
    rightnow = datetime.now()

    currentDateTime = rightnow.strftime("%m-%d-%Y_%H:%M:%S")
    todaysDate = startDateTime.strftime("%m-%d-%Y starting at %H:%M:%S")
    imgfile = "/home/pi/radbot/output/" + currentDateTime + ".png"
    rowcount = 0

    with open(filename, 'r') as datafile:

        plotting = csv.reader(datafile, delimiter=',')

        # Skip the headers and other rows above the actual data
        next(plotting)
        next(plotting)
        next(plotting)

        for ROWS in plotting:


            if b + 1 == buffer:
                # calc average etc.
                X.append(ROWS[0])
                USV.append(float(bufferSum/buffer))
                b = 0
                bufferSum = 0

                xintervals.append(buffCount)

                if math.floor(buffCount / interval) == buffCount / interval:

                    # clips the last 3 characters of the timestamp so the label is just HH:MM
                    clippedLabel = ROWS[0]
                    clippedLabel = clippedLabel[:-3]
                    xlabels.append(clippedLabel)

                else:
                    blankStr = ""
                    xlabels.append(blankStr)

                buffCount += 1

            else:
                b += 1
                bufferSum += float(ROWS[1])

            rowcount += 1
        
    # Set the plot title
    plt.title(todaysDate + '\nLocation: Washington DC')

    # set the X and Y axis labels
    plt.xlabel('Time (hh:mm)\n ')
    plt.ylabel('Avg. Dose over 30-min interval (µSv / hr)')

    # Plot the data
    ax = plt.subplot(111)
    ax.grid()
    ax.plot(X, USV)
    plt.xticks(rotation=45, ticks=xintervals, labels=xlabels)

    # create a file for the graph
    plt.savefig(imgfile)

    # plt.show()

    # Zero out the plot data
    X.clear()
    USV.clear()
    ax.clear()

    # close the file
    datafile.close()

    # return path to plot image
    return imgfile  

# decodeString : returns the serial data input as a string
#
def decodeString(serial):
    return serial.decode('utf-8')

# animate : live plots the CPS input from the serial data connection
#
def animate(i):

    with serial.Serial(port='/dev/ttyUSB0',
                       baudrate=9600,
                       timeout=1,
                       xonxoff=False,
                       rtscts=False,
                       dsrdtr=True) as s:

        # Pause for 2 seconds before reading data - I think this helps with the regex attribute error?
        sleep(2)

        # print(decodeString(s.readline()))

        try:

            # now = datetime.now()
            # currentDateTime = now.strftime("%m/%d/%Y, %H:%M:%S")

            x_values.append(time.time() - startTime)
            y_values.append(getCountsPerSecond(decodeString(s.readline())))

            plt.cla()
            plt.plot(x_values, y_values)

            plt.title('MightyOhm Test')
            plt.xlabel('Elapsed Time (seconds)')
            plt.ylabel('Counts Per Second')

            plt.show()

        finally:

            s.close()



# ANIMATION
# ani = FuncAnimation(plt.gcf(), animate, 1000)
# plt.show()
#


def radCalc(filepath):

    # csvdata = "/home/ian/PycharmProjects/radSurveyor/data/mightyOhmRadData_20220313_144342.csv"

    with open(filepath, 'r') as f:

        reader = csv.reader(f)
        tweetHeader1 = f.readline()

        # next(reader)  # Skip header row
        tweetHeader2 = f.readline()

        next(reader)
        next(reader)

        lines = []
        count = 0
        sum = 0

        for column in reader:
            lines.append(float(column[1]))
            count += 1
            sum += float(column[1])
        f.close()

    average = float(sum/count)
    maximum = max(lines)
    stdev = statistics.stdev(lines)
    now = datetime.now()
    todaysDate = now.strftime("%Y-%m-%d")
    timeNow = now.strftime("%H:%M:%S")

    # tweetString = "DCRadMonitor survey report for " + todaysDate + ": \n" + "(Units in µSv/hr)\n" + "AVG: " + format(average, '.3f') + "\nMAX: " + str(maximum) + "\nSTDEV: " + format(stdev, '.3f')
    tweetString = tweetHeader1 + tweetHeader2 + "(Units in µSv/hr)\n" + "AVG: " + format(average, '.3f') + "\nMAX: " + str(maximum) + "\nSTDEV: " + format(stdev, '.3f')
    return tweetString
    # print(tweetString)
    # client.create_tweet(text=tweetString)


def tweetWrapper():

    # start a data collection run
    fpath = writeSerialDataToFile()
    # fpath = "/home/pi/radbot/test.csv"

    # get the summary stats/text string for tweet
    tweetString = radCalc(fpath)

    # Generate a plot and save it as a .png file
    fig = plotDataFromFile(fpath)

    # Upload and tweet image/info about last run
    media = API.media_upload(fig)
    post_result = API.update_status(status=tweetString, media_ids=[media.media_id])


def main():
    
    tweetWrapper()

    # filepath = "/home/pi/radbot/test.csv"
    
    #print(fig)
    
#     hours = 0
#     
#     while hours < 2:
#     
#         tweetWrapper()
#         hours+=1
        
main()
